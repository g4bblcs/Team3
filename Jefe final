// JUEGO CON CAMINO VERTICAL Y JEFE ABAJO
// Copia todo este código en Processing y ejecuta

// Variables del jugador
float playerX = 400;
float playerY = 50; // En la parte superior del camino
float playerWidth = 40;
float playerHeight = 50;
float playerSpeed = 6;

// Variables del camino vertical (pasillo)
float roadX = 250; // Donde empieza el camino
float roadWidth = 300; // Ancho del pasillo

// Variables de munición
int ammo = 20; // Número limitado de disparos
int maxAmmo = 20;

// Variables del jefe (abajo en el camino)
float bossX = 350;
float bossY = 500;
float bossWidth = 120;
float bossHeight = 80;
int bossHealth = 15;
int bossMaxHealth = 15;
boolean bossHit = false;
int bossHitTimer = 0;
float bossSpeed = 3;
float bossDirection = 1;

// ArrayList de proyectiles
ArrayList<Projectile> projectiles = new ArrayList<Projectile>();

// Variables de control
int score = 0;
String gameState = "PLAYING"; // PLAYING, WIN, LOSE
int shootTimer = 0;

// Sistema de apuntado
float aimAngle = 0;

void setup() {
  size(800, 600);
}

void draw() {
  background(20, 20, 30);
  
  if (gameState.equals("PLAYING")) {
    playingGame();
  } else if (gameState.equals("WIN")) {
    showWinScreen();
  } else if (gameState.equals("LOSE")) {
    showLoseScreen();
  }
}

void playingGame() {
  // Dibujar área fuera del camino (oscura)
  fill(10, 10, 20);
  rect(0, 0, roadX, height); // Izquierda
  rect(roadX + roadWidth, 0, width - roadX - roadWidth, height); // Derecha
  
  // Dibujar el camino vertical (pasillo)
  fill(60, 60, 70);
  rect(roadX, 0, roadWidth, height);
  
  // Líneas del camino
  stroke(200, 200, 100);
  strokeWeight(2);
  for (int i = 0; i < height; i += 40) {
    line(roadX + roadWidth / 2, i, roadX + roadWidth / 2, i + 20);
  }
  
  // Bordes del camino
  stroke(255, 255, 255);
  strokeWeight(4);
  line(roadX, 0, roadX, height); // Borde izquierdo
  line(roadX + roadWidth, 0, roadX + roadWidth, height); // Borde derecho
  
  // Mover jugador (solo izquierda y derecha dentro del camino)
  if (keyPressed) {
    if (key == 'a' || key == 'A' || keyCode == LEFT) {
      if (playerX > roadX + 10) playerX -= playerSpeed;
    }
    if (key == 'd' || key == 'D' || keyCode == RIGHT) {
      if (playerX < roadX + roadWidth - playerWidth - 10) playerX += playerSpeed;
    }
  }
  
  // Calcular ángulo de apuntado hacia el mouse
  float centerX = playerX + playerWidth / 2;
  float centerY = playerY + playerHeight / 2;
  aimAngle = atan2(mouseY - centerY, mouseX - centerX);
  
  // Dibujar jugador
  fill(78, 205, 196);
  rect(playerX, playerY, playerWidth, playerHeight);
  
  // Línea de apuntado
  stroke(255, 255, 0);
  strokeWeight(3);
  float lineLength = 60;
  line(centerX, centerY, 
       centerX + cos(aimAngle) * lineLength, 
       centerY + sin(aimAngle) * lineLength);
  
  // Hitbox del jugador
  noFill();
  stroke(0, 255, 0);
  strokeWeight(2);
  rect(playerX, playerY, playerWidth, playerHeight);
  
  // Movimiento del jefe (izquierda y derecha en el fondo del camino)
  bossX += bossSpeed * bossDirection;
  if (bossX <= roadX + 20 || bossX >= roadX + roadWidth - bossWidth - 20) {
    bossDirection *= -1;
  }
  
  // Reducir cooldown de disparo
  if (shootTimer > 0) shootTimer--;
  
  // Actualizar y dibujar proyectiles del jugador
  for (int i = projectiles.size() - 1; i >= 0; i--) {
    Projectile proj = projectiles.get(i);
    proj.update();
    proj.display();
    
    // Verificar colisión con el jefe
    if (checkCollision(proj.x, proj.y, proj.width, proj.height,
                       bossX, bossY, bossWidth, bossHeight)) {
      bossHealth--;
      bossHit = true;
      bossHitTimer = 10;
      projectiles.remove(i);
      score++;
      
      // Verificar si el jefe fue derrotado
      if (bossHealth <= 0) {
        gameState = "WIN";
      }
    } else if (proj.y < 0 || proj.y > height || proj.x < roadX || proj.x > roadX + roadWidth) {
      // Eliminar proyectiles fuera del camino
      projectiles.remove(i);
    }
  }
  
  // Efecto de golpe
  if (bossHitTimer > 0) {
    bossHitTimer--;
    if (bossHitTimer == 0) bossHit = false;
  }
  
  // Dibujar jefe
  if (bossHit) {
    fill(255, 255, 255);
  } else {
    fill(231, 76, 60);
  }
  rect(bossX, bossY, bossWidth, bossHeight);
  
  // Cara del jefe (ojos)
  fill(0);
  ellipse(bossX + 30, bossY + 25, 15, 15);
  ellipse(bossX + 90, bossY + 25, 15, 15);
  
  // Hitbox del jefe
  noFill();
  if (bossHit) {
    stroke(255, 255, 0);
  } else {
    stroke(255, 0, 0);
  }
  strokeWeight(3);
  rect(bossX, bossY, bossWidth, bossHeight);
  
  // Barra de vida del jefe
  float barWidth = 120;
  float barHeight = 12;
  float barX = bossX;
  float barY = bossY - 25;
  
  fill(51, 51, 51);
  rect(barX, barY, barWidth, barHeight);
  
  fill(255, 0, 0);
  float healthWidth = (float)bossHealth / bossMaxHealth * barWidth;
  rect(barX, barY, healthWidth, barHeight);
  
  noFill();
  stroke(255);
  strokeWeight(2);
  rect(barX, barY, barWidth, barHeight);
  
  // UI - Panel de información
  fill(0, 0, 0, 180);
  rect(10, 10, 200, 110);
  
  fill(255);
  textSize(18);
  textAlign(LEFT);
  text("MUNICIÓN: " + ammo + "/" + maxAmmo, 20, 35);
  text("IMPACTOS: " + score, 20, 60);
  text("VIDA JEFE: " + bossHealth + "/" + bossMaxHealth, 20, 85);
  
  // Advertencia de munición baja
  if (ammo <= 5 && ammo > 0) {
    fill(255, 200, 0);
    textSize(16);
    text("¡MUNICIÓN BAJA!", 20, 110);
  } else if (ammo == 0) {
    fill(255, 0, 0);
    textSize(16);
    text("¡SIN MUNICIÓN!", 20, 110);
  }
  
  // Instrucciones
  fill(0, 0, 0, 180);
  rect(10, height - 90, 180, 80);
  fill(255);
  textSize(14);
  text("A/D: Mover", 20, height - 65);
  text("Mouse: Apuntar", 20, height - 45);
  text("Click: Disparar", 20, height - 25);
  
  // Verificar si perdió (sin munición y no mató al jefe)
  if (ammo == 0 && projectiles.size() == 0 && bossHealth > 0) {
    gameState = "LOSE";
  }
}

void showWinScreen() {
  background(0, 100, 0);
  fill(255, 255, 0);
  textSize(64);
  textAlign(CENTER);
  text("¡JEFE DERROTADO!", width / 2, height / 2 - 50);
  
  textSize(32);
  fill(255);
  text("Impactos: " + score, width / 2, height / 2 + 20);
  text("Munición restante: " + ammo, width / 2, height / 2 + 60);
  
  textSize(20);
  text("Presiona R para reiniciar", width / 2, height / 2 + 120);
}

void showLoseScreen() {
  background(100, 0, 0);
  fill(255, 0, 0);
  textSize(64);
  textAlign(CENTER);
  text("GAME OVER", width / 2, height / 2 - 50);
  
  textSize(32);
  fill(255);
  text("¡Te quedaste sin munición!", width / 2, height / 2 + 20);
  text("Impactos: " + score + "/" + bossMaxHealth, width / 2, height / 2 + 60);
  
  textSize(20);
  text("Presiona R para reiniciar", width / 2, height / 2 + 120);
}

void mousePressed() {
  if (gameState.equals("PLAYING") && shootTimer == 0 && ammo > 0) {
    float centerX = playerX + playerWidth / 2;
    float centerY = playerY + playerHeight / 2;
    projectiles.add(new Projectile(centerX, centerY, aimAngle));
    shootTimer = 20; // Cooldown de 20 frames
    ammo--; // Reducir munición
  }
}

void keyPressed() {
  // Reiniciar juego
  if ((key == 'r' || key == 'R') && !gameState.equals("PLAYING")) {
    resetGame();
  }
}

void resetGame() {
  gameState = "PLAYING";
  playerX = 400;
  playerY = 50; // Reinicia en la parte superior
  ammo = maxAmmo;
  bossX = 350;
  bossY = 500;
  bossHealth = bossMaxHealth;
  score = 0;
  projectiles.clear();
  bossDirection = 1;
}

// Función de detección de colisión rectangular
boolean checkCollision(float x1, float y1, float w1, float h1,
                       float x2, float y2, float w2, float h2) {
  return x1 < x2 + w2 &&
         x1 + w1 > x2 &&
         y1 < y2 + h2 &&
         y1 + h1 > y2;
}

// Clase Projectile con sistema de apuntado
class Projectile {
  float x, y;
  float width = 12;
  float height = 12;
  float speed = 8;
  float angle;
  float vx, vy;
  
  Projectile(float x, float y, float angle) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.vx = cos(angle) * speed;
    this.vy = sin(angle) * speed;
  }
  
  void update() {
    x += vx;
    y += vy;
  }
  
  void display() {
    fill(255, 200, 0);
    ellipse(x, y, width, height);
    
    noFill();
    stroke(255, 255, 0);
    strokeWeight(2);
    ellipse(x, y, width, height);
  }
}
